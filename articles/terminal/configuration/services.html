<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Services (Dependency Injection) </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Services (Dependency Injection) ">
      
      
      <link rel="icon" href="../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/perpetualintelligence/docs/blob/main/docfx_project/articles/terminal/configuration/services.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.ico" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="services-dependency-injection">Services (Dependency Injection)</h1>

<p><code>OneImlx.Terminal</code> supports the dependency injection (DI) software design pattern, a technique for achieving Inversion of Control (IoC) between classes and their dependencies. This framework allows for easy integration with <a href="options.html">configuration options</a> and <a href="logging.html">logging</a> to create robust, maintainable, and scalable terminal applications.</p>
<h2 id="extension-methods">Extension Methods</h2>
<p>To facilitate the integration of <code>OneImlx.Terminal</code> services into a host application's dependency injection container, the following classes offer extension methods:</p>
<ul>
<li><a class="xref" href="../../../api/OneImlx.Terminal.Extensions.IServiceCollectionExtensions.html">IServiceCollectionExtensions</a>: Offers extension methods to register and configure <code>OneImlx.Terminal</code> services within the host application's dependency injection container.</li>
<li><a class="xref" href="../../../api/OneImlx.Terminal.Extensions.IHostExtensions.html">IHostExtensions</a>: Provides an extension method to run the terminal routing, enabling the execution of commands within the terminal application.</li>
<li><a class="xref" href="../../../api/OneImlx.Terminal.Extensions.ITerminalBuilderExtensions.html">ITerminalBuilderExtensions</a>: Enhances the terminal builder with additional configuration and customization options.</li>
<li><a class="xref" href="../../../api/OneImlx.Terminal.Extensions.ICommandBuilderExtensions.html">ICommandBuilderExtensions</a>: Provides extension methods to aid in the configuration and creation of commands in the terminal application.</li>
<li><a class="xref" href="../../../api/OneImlx.Terminal.Extensions.IOptionBuilderExtensions.html">IOptionBuilderExtensions</a>: Offers methods for defining and configuring command options, ensuring their proper integration and validation.</li>
<li><a class="xref" href="../../../api/OneImlx.Terminal.Configuration.Options.TerminalOptions.html">TerminalOptions</a>: Represents the configurable options for the <code>OneImlx.Terminal</code> terminal application, allowing for customization of its behavior.</li>
</ul>
<h2 id="hosted-service">Hosted Service</h2>
<p>You need to register a <a class="xref" href="../../../api/OneImlx.Terminal.Hosting.TerminalHostedService.html">TerminalHostedService</a> using standard .NET extension method <a href="xref:Microsoft.Extensions.DependencyInjection.ServiceCollectionHostedServiceExtensions.AddHostedService%601"><code>AddHostedService</code></a>. This will enable you to define and customize terminal startup and lifetime behavior.</p>
<pre><code class="lang-csharp">collection.AddHostedService&lt;TestAppHostedService&gt;();
</code></pre>
<h2 id="http-client">HTTP Client</h2>
<p>If you are using an online license then you will need to register the HttpClient service in your application. This service is used to communicate with the our licensing server to validate the license.</p>
<pre><code class="lang-csharp">collection.AddHttpClient(&quot;demo-http&quot;);
</code></pre>
<p>The <code>demo-http</code> is the name of the HTTP client instance. You can use any name you like.</p>
<blockquote>
<p>INFO: The HTTP client registration is required only if you are using an online license.</p>
</blockquote>
<h2 id="integrate-framework">Integrate Framework</h2>
<p>Integrating the <code>OneImlx.Terminal</code> framework into a .NET application is straightforward with two standard methods designed for most use cases. These methods facilitate the registration of terminal services within your application's Dependency Injection (DI) service collection. For advanced scenarios, the framework also allows for more granular control by using individual services.</p>
<h3 id="addterminaldefault">AddTerminalDefault</h3>
<p>The <a href="xref:OneImlx.Terminal.Extensions.IServiceCollectionExtensions.AddTerminalDefault%60%60%603"><code>AddTerminalDefault</code></a> method adds essential terminal functionalities to your application, such as command handling, text processing, and help provider. It registers the foundational terminal services in your project, allowing customization through setup actions.</p>
<pre><code class="lang-csharp">ITerminalBuilder terminalBuilder = collection.AddTerminalDefault&lt;TerminalInMemoryCommandStore, TerminalUnicodeTextHandler, TerminalHelpLoggerProvider&gt;(new TerminalUnicodeTextHandler(),
    options =&gt;
    {
        options.Id = TerminalIdentifiers.TestApplicationId;
        options.Licensing.LicenseFile = &quot;C:\\this\\perpetualintelligence\\tools\\lic\\oneimlx-terminal-demo-test.json&quot;;
        options.Router.Caret = &quot;&gt; &quot;;
    }
);
</code></pre>
<h3 id="addterminalconsole">AddTerminalConsole</h3>
<p>The <a href="xref:OneImlx.Terminal.Extensions.IServiceCollectionExtensions.AddTerminalConsole%60%60%60%604"><code>AddTerminalConsole</code></a> method extends <code>AddTerminalDefault</code> by adding console-specific functionalities. This method integrates additional services tailored for console applications, building on the foundational terminal services.</p>
<pre><code class="lang-csharp">ITerminalBuilder terminalBuilder = collection.AddTerminalConsole&lt;TerminalInMemoryCommandStore, TerminalUnicodeTextHandler, TerminalHelpConsoleProvider, TerminalSystemConsole&gt;(new TerminalUnicodeTextHandler(),
    options =&gt;
    {
        options.Id = TerminalIdentifiers.TestApplicationId;
        options.Licensing.LicenseFile = &quot;C:\\this\\perpetualintelligence\\tools\\lic\\oneimlx-terminal-demo-test.json&quot;;
        options.Router.Caret = &quot;&gt; &quot;;
    }
);
</code></pre>
<h3 id="advanced-use-cases">Advanced Use Cases</h3>
<p>For more detailed control and customization, developers can use specific services from the OneImlx.Terminal framework. This option supports creating tailored terminal experiences for unique application needs, offering flexibility for intricate setups.</p>
<h2 id="add-descriptors">Add Descriptors</h2>
<p>The <a class="xref" href="../../../api/OneImlx.Terminal.Extensions.ITerminalBuilderExtensions.html"><code>ITerminalBuilder</code></a> extensions offer both explicit and declarative syntaxes for registering command, argument and option descriptors within the service collection.</p>
<p>When deciding between explicit and declarative syntax for command registration, consider both usability and performance implications. Explicit syntax is more efficient as it avoids reflection, unlike declarative syntax, which may be more resource-intensive due to its use of reflection. However, for applications with intricate command hierarchies, the straightforward usability of declarative syntax could be appealing despite potential performance costs. Given that command registration is a startup activity, the performance impact primarily affects initial load time, not runtime. Developers should assess these factors based on their application's specific needs and performance requirements.</p>
<h3 id="explicit-syntax">Explicit Syntax</h3>
<p>The explicit syntax method for command registration in the framework is a direct and controlled approach to integrating command functionalities into your .NET application. This method primarily revolves around the use of hosting builders, which are sophisticated tools provided by the framework to manually define and register command descriptors with the service collection.</p>
<pre><code class="lang-csharp">private static void RegisterCommands(ITerminalBuilder terminalBuilder)
{
    terminalBuilder.DefineCommand&lt;TestChecker, TestRunner&gt;(&quot;test&quot;, &quot;Test command&quot;, &quot;Test Description&quot;, Commands.CommandType.Root, Commands.CommandFlags.None)
                        .DefineArgument(1, &quot;arg1&quot;, nameof(String), &quot;The first argument&quot;, Commands.ArgumentFlags.None)
                            .Add()
                        .DefineArgument(2, &quot;arg2&quot;, nameof(Int32), &quot;The second argument&quot;, Commands.ArgumentFlags.None)
                            .Add()
                        .DefineOption(&quot;version&quot;, nameof(String), &quot;The version option&quot;, Commands.OptionFlags.None, &quot;v&quot;)
                            .Add()
                    .Add();
}
</code></pre>
<blockquote>
<p>NOTE: In the explicit syntax for command registration, the <code>Add()</code> method is necessary for finalizing and registering commands, arguments or options. It commits an element definition and adds the command descriptor to the service collection.</p>
</blockquote>
<h3 id="declarative-syntax">Declarative Syntax</h3>
<p>Alternatively, descriptors can also be defined directly on command runners using <a class="xref" href="../../../api/OneImlx.Terminal.Commands.Declarative.html">declarative attributes</a>.</p>
<pre><code class="lang-csharp">[CommandDescriptor(&quot;test&quot;, &quot;Test App&quot;, &quot;Test application description.&quot;, Commands.CommandType.Root, Commands.CommandFlags.None)]
[OptionDescriptor(&quot;version&quot;, nameof(String), &quot;Test version description&quot;, Commands.OptionFlags.None, &quot;v&quot;)]
[CommandChecker(typeof(CommandChecker))]
public class TestRunner : CommandRunner&lt;CommandRunnerResult&gt;, IDeclarativeRunner
{

}
</code></pre>
<p>The framework automatically discovers and registers these command descriptors through the <code>AddDeclarative...</code> extension methods.</p>
<pre><code class="lang-csharp">// Add all the commands in the assembly using declarative syntax.
terminalBuilder.AddDeclarativeAssembly&lt;TestRunner&gt;();
</code></pre>
<blockquote>
<p>NOTE: For declarative syntax it is necessrary to implement @OneImlx.Terminal.Commands.IDeclarativeRunner interface in the command runner class.</p>
</blockquote>
<h2 id="complete-integration-example">Complete Integration Example</h2>
<p>Below is an example showing the <code>AddTerminalConsole</code> method in action, configuring the terminal framework for a console application with an online demo license.</p>
<pre><code class="lang-csharp"> private static void ConfigureOneImlxTerminal(IServiceCollection collection)
{
    // Configure the hosted service
    collection.AddHostedService&lt;TestAppHostedService&gt;();

    // We are using online license so configure HTTP
    collection.AddHttpClient(&quot;demo-http&quot;);

    // NOTE:
    // Specify your demo or commercial license file.
    // Specify your application id.
    ITerminalBuilder terminalBuilder = collection.AddTerminalConsole&lt;TerminalInMemoryCommandStore, TerminalUnicodeTextHandler, TerminalHelpConsoleProvider, TerminalSystemConsole&gt;(new TerminalUnicodeTextHandler(),
        options =&gt;
        {
            options.Id = TerminalIdentifiers.TestApplicationId;
            options.Licensing.LicenseFile = &quot;C:\\this\\perpetualintelligence\\tools\\lic\\oneimlx-terminal-demo-test.json&quot;;
            options.Router.Caret = &quot;&gt; &quot;;
        }
    );

    // Add commands using declarative syntax.
    terminalBuilder.AddDeclarativeAssembly&lt;TestRunner&gt;();
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/perpetualintelligence/docs/blob/main/docfx_project/articles/terminal/configuration/services.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright &copy; 2019-2025. Perpetual Intelligence&reg; L.L.C. All Rights Reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
